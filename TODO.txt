TODO:  
	BASIC PLAYER THROWING GRENADE (with animation) (2h) []
		GRENADE ALSO HAVE 2 STATE MACHINE: 
			Physic state machine
				First hop
				Second hop
			Animation state machine  
				Rotating
				Explode 
			
		how the grenade moves ?? [X] 
			total 2 hop 
			total time: (284 - 249  + 1) = 36 frames (30fps)
			separate the lerp into 2 axes x, y:  
				each controlled by it's own t 
				the up and down action will have separate lerp 
				goals: 
					from 0 to a in b time 
					first let's try linear: 
						y: 
							up 
							down 
						x: 

			define (use for player as well): 
				upCurve:-(yt - 1)^2 + 1  
				downCurve: -yt^2 + 1

			first hop:
				Idea: 
					the hop gonna be a parabolla from 
						throw base to peak being half 

				peak = (1017, 513);
				throw base = (798, 648)

				time: (266 - 249 + 1) = 18 frames -> .6s 
				height (from throw base to peak): (513 - 648) + 1 = 136 pixels; -> 136/1080 *2  = .251851
				how far: 1600 - 1261 + 1 =  340/1920 * 2.714 = .4806

				i need this to go from 0 to .4806/2 in .3s -> the speed is 

				y: 
					up: upCurve * height
					down: downCurve * height
				x: xt * how_far/2

				x += playerPos.x;
				y += playerPos.y;

				What i need to do:
					have an accumulator for the time: 
						from 0 to the time we want -> normalize it to range 0 -> 1, accumulatortime/wantedtime

			second hop:
				peak = (1418, 662)
				bounce base = (1261, 742)
				time: (284 - 267 + 1) = 18 frames -> .6s
				height: 742 - 662 + 1 = 81 -> 81/1080 *2 = .15
				how far (half): (1017 - 798) + 1 = 220; -> 220/1920 * 2.714 = 0.31097;


				y: 
					up: upCurve * height
					down: downCurve * height
				x: xt * how_far/2

				x += groundHit.x;
				y += groundHit.y;

			Currently the old jumping method that we use does not adjust the speed of the interpolation using specific time frame (1h) [X] @Current 
			but instead use the specific speed that seems good 

		grenade animation (1 frame) [X]

		player throwing animation [] (can't find the animation in the image) (1 frame) 

	@Reminder: Check hops how_far again 

	THE THROWING ANIMATION SHOULD BE INDEPENDENT FROM LEG ANIMATION (2h) []

	CAN THROW THE GRENADE DEPENDS ON THE FACING (1h) [] 

	CAN THROW MULTIPLE GRENADE (2h) []

	ENEMY THROWING GRENADE (with animation) (2h) []

	PLAYER SHOOTING (2h) [] 

	CHANGE THE PLAYER JUMPING MECHANISM WITH THE NEW MECHANISM (GRENADE BOUNCE) (1h) []

	PLAYER KNOCK BACK PHYSIC []
		-> knock back only plays when hit by projectile (bomb, bullet,...)
		-> Figure out what's the knock back curve looks like 

	LOAD THE LEVEL METADATA (JSON) FROM A FILE SO THAT NO NEED TO RECOMPILE (4h) []

	THE X AXIS CONVERSION SEEMS NOT SUPER ACCURATE (The background thing is off my a few pixels ?) (2h) []

	ONLY LOAD THE GAME ASSETS ONCE AT THE START OF THE LEVEL (2h) []

	HAVE A FRAMEWORK FOR CREATING AN ENTITY IN THE GAME (4h): []
		AN ENTITY IN THE GAME INCLUDES: 
			COLLIDER 
			PHYSICS STATE MACHINE 	
			ANIMATIONS
			ANIMATION STATE MACHINE 

		INJECT ALL OF THESE FROM OUTSIDE, SOMEHOW

		MAYBE HAVE A CPU CONTROLLED ENTITY AND PLAYER CONTROLLED ENTITY ? 
			CPU CONTROLLED ENTITY HAVING A UPDATE() without input
			PLAYER CONTROLLED ENTITY HAVING A UPDATE() input

	TAKE NEW WEAPON (2h) []

	ENEMY ANIMATIONS (2h) []
		ANIMATION PTS [] 
		ANIMATION Installation []
	
	PLACE ALL THE STUFF ON THE LEVEL (4h) [] 
		have the camera working [X]
			the camera will move with the player when the player go about 1/3 of the width 
		have all the colliders in place as well [X] 
			-> first figure out all the collider rects in PTS first [X]
			-> then write it out in a datastructure then load into the map  [X]
		place hostages into RIGHT places, with animation (2h) [X] 

		place the sceneries into RIGHT place as well, with animation (4h) [] 
			have the houses explode when it collide with player 
			let's test with something that is the most visible and the easiest to implement  
				-> The waterfall -> test out with PTS first  
				-> add more collider blocks on the level [X]

			NOW PLACE: 
				THE OTHER HALF OF THE WATERFALL (1h) [X] 
					0, 346, 832, 304
					rect: 3320, 0, 832, 304
				THE RIVER (1h) [] @Later
				THE HOUSES (1h) [] @Later
			INTO THE LEVEL 

	THE CAMERA THAT FOLLOWS THE PLAYER HAVE SOME TWEENING (2h) [] 
		this is the link to the easing video: https://www.youtube.com/watch?v=zLh0K1PdUbc&ab_channel=CodingMath

	REFACTOR THE LEVEL1 INTO ANOTHER CLASS, THINGS STARTING TO GET CLUSTERED (2h) []

	ENEMY GENERATION (2h) [] 

	HAVE A GENERAL STATE MACHINE CLASS THAT CAN BE REUSE (2h) []

	LOAD THE ANIMATION METADATA FROM A FILE SO THAT NO NEED TO RECOMPILE (2h) []

	REBELS AI (4h) []

	SIMPLE BOSS FIGHT (4h) []

	DO THE ACTUAL GOOD LOOKING ANIMATION (2h) []

	PLAYER ANIMATION TRANSITION (4h) []

	NEED ONE WAY PLATFORM (2h) []

	INPUT BUFFERING FOR GAMEPLAY MOVEMENT (4h) []

	CLEAN THE PROJECT STRUCTOR: EACH BACKEND IN IT'S OWN FOLDER (1h) []

	INPUT TIMING (FOR VARIABLE JUMP AND ANIMATION TRANSITION AND STUFF) (4h) []

	WHEN SHOULD WE WRITE A LEVEL EDITOR ?? []
		-> when level1 done, have proper structure for a level, a separate file for level 

		@Idea: Could we use Figma as a level editor ??  
			-> export the json file then parse it and generate all the level data 

	PARALAX BACKGROUND (2h) []

	RENDER ONLY PART OF THE MAP (2h) []
		-> get the portion of the map and only render that part 
		-> may be get 2 mapsize portion so that the scrolling smoother
		-> only get new portion when the camera get's move by so much :v (event = camera move by X -> append new portion)

	PHAN HOACH KHONG GIAN (4h) []

	DESTROY ALL THE FONT RESOURCES AFTER USING (SDL DESTROY) -> CURRENTLY HAVE MEMORY LEAKS (1H) []

BUG: 
	FIXME: collision on the hortizontal side not working ?? 
		-> this happens because the game only checking a single collision at a time  

	FIXME: from background to collider have some jittery when the background sliding, maybe because it's the updating order Entity 
		-> pretty everything seems jittery
		-> basically i see the shaking i believe

		Pixel snapping is the problem
		Possible Reason: 
			the resolution is too small so the pixel snapping might have some hard time to snap, 
			maybe adjust to a bigger resolution and somehow stretch the game sprites to fixed that instead of stretch 304x224 to x3
			-> meaning the sprites is still in their own pixel size by the position will be way more precise since the range is larger 


	THE FRAMES LOOK DISTORED BECAUSE THE CALCULATED AXIS IS KINDA OFF []  
	
DONE: 
	ENEMY PLACEMENT (2h) [X] 
		place more enemies on to the level 

	ENEMY INTERACTION (SLASHING) WITH PLAYER (2h) [X] 
		-> Player standing death animation plays when get slash [X] 

	HOSTAGE ONLY UNTIED WHEN THE PLAYER PRESS J (2h) [X] 

	ENEMY (2h) [X] 
	LOCK THE MAP KEEP THE PLAYER FROM SEEING THE MAGENTA BACKGROUND (.5h) [X] 

	// Camera state -> @Revisit: Check the coordinate of these again (1h) [X] 
	MIGRATE THE RESOLUTION TO USE 304X224 RESOLUTION (2h) [X] 
		-> what need to be changed  
		the convert function and the SDLUtil conversion function 

	// FIXME: [X]
	// the player position or anything that's displayed on the screen is only screen coord, not world coord
	// -> only transform the position when rendering, the processing information should be world space 

	DO SOME LEVEL1 CAMERA WORK (like for different part of the level the camera change y pos) (2h) [X] -> basically working
		-> Have the opening scene for level 1 
			-> parachute slowly comes down 

			x axis is based on the player 
			-> camera state is based on the player's x axis -> and control the y axis 
			-> if go too soon the white part will be shown

			// Camera state -> @Revisit: Check the coordinate of these again 
				opening position: 0, 64, 320, 224
				after landing position: 0, 80, 320, 224
				waterfall step 1: 3235, 67, 320, 224
				waterfall step 2: 3339, 41, 320, 224
				waterfall step 3: 3441, 14, 320, 224
				waterfall step 4: 3501, 0, 320, 224
				waterfall step 5: 3501, 0, 320, 224
			Idea: interplolate the position between the states @Later  

		-> where should we up the camera (.5h) [X] 
		-> what the behaviour should be (1h) [X]

	PLACE ALL THE COLLIDER IN LEVEL1 (1h) [X] 
	WORK ON THE CAMERA APPLY CODE (2h) [X] 
		Idea: have an interface with apply camera method then collect all of the objects in a vector ?? 
		Another Idea: 
			have a camera class with an apply method which takes an interface 
			and apply camera transformation on it @UseThis 

	PUT THE PLAYER CODE IN OTHER FILE (1h) [X] 
	HAVE ONE GOOD HOSTAGES (4h) [X]
		need animations  (1 frame) [X]
		need state machine (physics, animation) [X]
		need interactions with player [X]
		
	-> wrap them up and place them all over the map [X] 

	FINISH THE BASIC SPRITESHEET ANIMATION FOR THE PLAYER IN PTS (2h) [X] @Current - the leg is still not done 

	FULLSCREEN BUG: AFTER TOGGLE THE FULLSCREEN VS SMALLSCREEN, TEXTURE TURN BLACK
	FIX: black background when having transparent background (2h) 
		(normal rendering works, only the portion not working) [X]

	FIX THE SLOW UPDATING OF MOVING IMAGE FIRST THEN SOLVE THIS ONE LATER  [X]

	FIX: THERE ARE SOME FLICKERING WITH THE OLD POSITION WHEN CHANGING TO THE NEXT ANIMATION [X]
		i notice that the flickering occur when i release the button 
		and the next animation show it original position then shifted back to player position
		this could be a foundational error when the image position just keep sliding when i'm moving 

	DO THE PLAYER ANIMATION CHANGING (2h) [X]
		-> Desc: animation states: IDLE, JUMP, FALL, WALK (with direction as well) > Each just a frame 
		-> animation state changing now works (2h) [X]
		-> do the animation changing (2h) [X] 
		-> do the animation flip (1h) [X] 
	
	ATTACH THE ANIMATION WITH THE COLLIDER (4h) [X]
		-> just attach animation pos with the collider, that will work [X]

	HAVE A DATASTRUCTURE FOR ANIMATION (4h) []
		-> load the animation using the data structure [X]
		target: Load Marco Rossi character [X]
			-> first loading the first half [X]
			-> load the second half [X]
			-> attach both of them [X]
	COLLISION RESOLVER PROBLEM (4h) [X]
		-> using SweptAABB should fix the problem 
		-> look into the Separating Axis Theorem (SAT) or the Circle-Circle 
		IMPLEMENT THE SWEPTAABB 

	ROUGH CAMERA SYSTEM (4h) [X] 
		-> load the mission1_level and test the camera [X]
	ROUGH PHYSICS  (2h) [X]
		-> COLLISION: [X]
			-> box collider 
			-> circle collider (do this first)
			-> line collision 
			-> capsule collision 

		PHAKE PHYSICS: @Backburner - done 50%
			all the physics will be just state machine and interpolation with different ease function
			state: 
				jump -> from bottom to peak 
				fall -> from peak to bottom (or some ) -> gravity is just fall state 
				onground -> just pure left and right move - no fall, no jump

			let's consider moving (left, right - raw translate no animation or anything) is not a state machine:)) 
				-> so that it can combine with both jump and fall 

			 -> PHYSICS STATE MACHINE DIFFERENT FROM ANIMATION STATE MACHINE 
			 -> LET'S MAKES A PHYSICS STATE MACHINE: 
				state: 
					onground -> just pure left and right move - no fall, no jump @1st 
					jump -> from bottom to peak 
					fall -> from peak to bottom (or some ) -> gravity is just fall state 

	SHOWING DEBUG INFO (2h) [X]
		text: Millis per frame: 42.1196, FPS: 23.7419  [X]

		line: line collider [X]
		dot [X]
		rectangle: box collider  [X]
		circle: circle collider  [X]

	GO FULL SCREEN (2h) [X]
		2 solutions: 
			use fixed resolution then scale it up (this one seems simpler) -> @@@ use this 
			or scale everything to match the solution ?? 
	NORMALIZED COORDINATE SYSTEM (4h) [X]
		-> coordinate goes from -1 to 1 on each axis (the horizontal might be larger than abs(1) cause it's longer :v)
		-> use the normalized coord in the game code 
		-> the backend gonna translate convert it back to the one it needs 
	USING TILED SPRITE SHEET (2h) [X]
		-> load a single texture into an array of animation using 2 inputs: rows, columns  
	ROUGH ANIMATION SYSTEM (2h) [X]
	DOUBLE BUFFERING SO THAT WE DON'T SEE THE TEAR ON THE SCREEN (2h) [X] - we still saw the tear, kinda :))
	GAME LOOP WITH GOOD TIMING IN SDL2 (2h) [X]
	GET THE GAME INPUT WORKING (1h) [X]
	ROUGH CONTROL (2h) [X]
	PLATFORM INDEPENDENT THE WHOLE THING (2h) [X]nternet (kind of)